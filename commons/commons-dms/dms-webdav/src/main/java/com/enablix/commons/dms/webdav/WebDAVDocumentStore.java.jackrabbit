package com.enablix.commons.dms.webdav;

import java.io.IOException;
import java.io.InputStream;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.httpclient.Credentials;
import org.apache.commons.httpclient.HostConfiguration;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpConnectionManager;
import org.apache.commons.httpclient.HttpException;
import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;
import org.apache.commons.httpclient.UsernamePasswordCredentials;
import org.apache.commons.httpclient.auth.AuthScope;
import org.apache.commons.httpclient.methods.GetMethod;
import org.apache.commons.httpclient.methods.InputStreamRequestEntity;
import org.apache.commons.httpclient.methods.RequestEntity;
import org.apache.commons.httpclient.params.HttpConnectionManagerParams;
import org.apache.jackrabbit.webdav.client.methods.PutMethod;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.enablix.commons.config.ConfigurationProvider;
import com.enablix.commons.dms.DocumentStoreConstants;
import com.enablix.commons.dms.api.Document;
import com.enablix.commons.dms.api.DocumentBuilder;
import com.enablix.commons.dms.api.DocumentMetadata;
import com.enablix.commons.dms.api.DocumentStore;
import com.enablix.commons.util.StringUtil;
import com.enablix.core.domain.config.Configuration;

@Component
public class WebDAVDocumentStore implements DocumentStore<WebDAVDocumentMetadata, WebDAVDocument> {

	private static final Logger LOGGER = LoggerFactory.getLogger(WebDAVDocumentStore.class);
	
	private static final String BASE_DOC_PATH_KEY = "BASE_DOC_PATH";

	private static final String USERNAME_KEY = "USERNAME";

	private static final String PASSWORD_KEY = "PASSWORD";
	
	private static final String HOST_KEY = "HOST";
	
	private static final String MAX_HOST_CONNECTIONS_KEY = "MAX_HOST_CONNECTIONS";

	private static final String CONN_PARAMS_PREFIX = "conn.params.";

	@Autowired
	private ConfigurationProvider configProvider;
	
	@Autowired
	private WebDAVDocumentBuilder docBuilder;

	@Override
	public WebDAVDocumentMetadata save(WebDAVDocument document, String contentPath) throws IOException {
		
		try {
		    HttpClient client = createHttpClient();

		    Configuration config = configProvider.getConfiguration(DocumentStoreConstants.DOC_STORE_CONFIG_KEY);

			String baseWebDAVPath = config.getStringValue(BASE_DOC_PATH_KEY);

		    String fileLocation = baseWebDAVPath + createFilepath(document, contentPath);
			fileLocation = URLEncoder.encode(fileLocation, "UTF-8");
			
		    PutMethod method = new PutMethod(fileLocation);
		    RequestEntity requestEntity = new InputStreamRequestEntity(document.getDataStream());
		    method.setRequestEntity(requestEntity);
		    client.executeMethod(method);
		    
		    document.getMetadata().setFileLocation(fileLocation);
		    
		    LOGGER.debug(method.getStatusCode() + " " + method.getStatusText());
		    
		} catch(HttpException ex){
			LOGGER.error("Error saving document on webDAV server", ex);
			throw ex;
			
		} catch(IOException ex){
		    LOGGER.error("Error saving document on webDAV server", ex);
		    throw ex;
		}
		
		return document.getMetadata();
	}

	private HttpClient createHttpClient() {

		Configuration config = configProvider.getConfiguration(DocumentStoreConstants.DOC_STORE_CONFIG_KEY);

		// TODO: initialization should be done once only instead of reading the properties on each call
		String userName = config.getStringValue(USERNAME_KEY);
		String password = config.getStringValue(PASSWORD_KEY);
		String host = "stbeehive.oracle.com"; //config.getStringValue(HOST_KEY);
		
		String maxConn = config.getStringValue(MAX_HOST_CONNECTIONS_KEY);
		int maxHostConnections = 10;
		
		if (!StringUtil.isEmpty(maxConn)) {
			
			try {
				maxHostConnections = Integer.parseInt(maxConn);
			} catch (NumberFormatException e) {
				LOGGER.error("Invalid max host connection value [{}]", maxConn);
				maxHostConnections = 10;
			}
		}
		
		Map<String, Object> connParams = new HashMap<>();
		
		for (Map.Entry<String, Object> configProp : config.getConfig().entrySet()) {
			String key = configProp.getKey();
			if (key.startsWith(CONN_PARAMS_PREFIX)) {
				String connParamKey = key.substring(CONN_PARAMS_PREFIX.length());
				connParams.put(connParamKey, configProp.getValue());
			}
		}
		
		HostConfiguration hostConfig = new HostConfiguration();
        hostConfig.setHost(host); 
        
        HttpConnectionManager connectionManager = new MultiThreadedHttpConnectionManager();
        HttpConnectionManagerParams params = new HttpConnectionManagerParams();
        
        params.setMaxConnectionsPerHost(hostConfig, maxHostConnections);
        
        for (Map.Entry<String, Object> connParam : connParams.entrySet()) {
        	params.setParameter(connParam.getKey(), connParam.getValue());
        }
        
        connectionManager.setParams(params);  
        
        
        HttpClient client = new HttpClient(connectionManager);
        client.setHostConfiguration(hostConfig);

        Credentials creds = new UsernamePasswordCredentials(userName, password);
		client.getState().setCredentials(AuthScope.ANY, creds);
		
		return client;
	}

	@Override
	public WebDAVDocument load(WebDAVDocumentMetadata docMetadata) throws IOException {
		
		WebDAVDocument document = null;
		
		try {
		    HttpClient client = createHttpClient();

		    String fileLocation = docMetadata.getFileLocation();
			
		    GetMethod method = new GetMethod(URLDecoder.decode(fileLocation, "UTF-8"));
		    client.executeMethod(method);
		    
		    client.executeMethod(method);
		    LOGGER.debug(method.getStatusCode() + " " + method.getStatusText());
		    
		    if (method.getStatusCode() == 200) {
		    	
		    	InputStream docStream = method.getResponseBodyAsStream();
		    	document = new WebDAVDocument(docStream, docMetadata);
		    	
		    } else {
		    	throw new IOException("Unable to read file content. Status - " 
		    			+ method.getStatusCode() + " " + method.getStatusText());
		    }
		    
		} catch(HttpException ex){
			LOGGER.error("Error saving document on webDAV server", ex);
			throw ex;
			
		} catch(IOException ex){
		    LOGGER.error("Error saving document on webDAV server", ex);
		    throw ex;
		}

		return document;
	}

	private String createFilepath(WebDAVDocument document, String contentPath) {
		return "/" + contentPath + "/" + document.getMetadata().getName();
	}
	
	@Override
	public boolean canHandle(DocumentMetadata docMetadata) {
		return docMetadata instanceof WebDAVDocumentMetadata;
	}

	@Override
	public boolean canHandle(Document<?> doc) {
		return doc instanceof WebDAVDocument;
	}

	@Override
	public String type() {
		return "WEBDAV";
	}

	@Override
	public DocumentBuilder<WebDAVDocumentMetadata, WebDAVDocument> getDocumentBuilder() {
		return docBuilder;
	}

}
